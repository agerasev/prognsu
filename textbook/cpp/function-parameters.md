---
title: Эффективная передача параметров в функцию
menu: textbook-cpp
---

Давайте напишем функцию `add_item`, которая принимает контейнер `vector<string>` и добавляет в конец контейнера новый элемент. Мы могли бы начать со следующего кода:

```cpp
#include <vector>
#include <string>
#include <iostream>

using namespace std;

// Здесь есть проблема
void add_item(vector<string> vec) {
    vec.push_back("New item!");
}

int main() {
    vector<string> vec;
    add_item(vec);

    for (string s : vec) {
        cout << s << '\n';
    }

    return 0;
}
```

Если мы скомпилируем и запустим эту программу, то обнаружим, что после вызова функции `add_item` контейнер `vec` остался пустым. Проблема в том, что мы передали в функцию *копию* объекта `vec`. Внутри функции к этой копии был добавлен новый элемент, а после выхода из функции копия была удалена.

Следующий вариант нашей программы уже будет делать то что мы хотим:

```cpp
// Здесь есть проблема
vector<string> add_item(vector<string> vec) {
    vec.push_back("New item!");
    return vec;
}

int main() {
    vector<string> vec;
    vector<string> vec2 = add_item(vec);

    for (string s : vec2) {
        cout << s << '\n';
    }

    return 0;
}
```

Такая реализация, однако, является очень плохой идеей. Мы всего лишь хотели добавить один элемент в вектор, а вместо этого получили копию вектора с добавленным новым элементом. Помимо неверной логики работы, мы получили потенциальную проблему с производительностью: вместо константного времени мы тратим линейное время на добавление элемента в вектор.

Правильное решение нашей задачи в C++ выглядит следующим образом:

```cpp
void add_item(vector<string>& vec) {
    vec.push_back("New item!");
}

int main() {
    vector<string> vec;
    add_item(vec);

    for (string s : vec) {
        cout << s << '\n';
    }

    return 0;
}
```

Символ амперсанд `&` позволяет передать в функцию ссылку на параметр. Работа с параметром внутри функции не изменяется, но вместо копии мы имеем дело именно с тем объектом, который был передан в функцию. Таким образом, мы избавились от лишнего копирования и реализовали правильную логику работы программы.

Рассмотрим другой пример. Допустим, мы хотим передать вектор в функцию, которая будет анализировать элементы вектора, но не будет его изменять. Например:

```cpp
// Здесь есть проблема
int count_greetings(vector<string>& vec) {
    int counter = 0;
    for (string s : vec) {
        if (s == "Hello") {
            ++counter;
        }
    }
    return counter;
}
```

Мы уже достаточно грамотные и сразу передали вектор по ссылке, чтобы избежать ненужного копирования. Однако в текущем виде функция `count_greetings` имеет другую, более тонкую, проблему. Если мы нарушим договоренность и изменим вектор внутри функции `count_greetings`, то компилятор не увидит в этом проблемы. Проблему будем искать мы, когда поймем, что в каком-то месте нашей программы происходит неправильная манипуляция с вектором.

Хорошим стилем в данном случае является передача параметра по константной ссылке:

```cpp
int count_greetings(const vector<string>& vec) {
    int counter = 0;
    for (const string& s : vec) {
        if (s == "Hello") {
            ++counter;
        }
    }
    return counter;
}
```

Теперь компилятор не позволит изменить объект `vec` внутри функции `count_greetings`. Кроме того, теперь в коде явно выражена мысль о том, что объект передается в функцию только для чтения. Такой код проще читать и понимать логику его работы. Обратите внимание, что мы воспользовались константной ссылкой при определении переменной в цикле `for`. Здесь мы имеем дело с аналогичной ситуацией: в предыдущей версии в переменную `s` по очереди копировался каждый элемент вектора. Теперь же мы перебираем в цикле константные ссылки на объекты, не копируя их.

Иногда необходимо изменять элементы вектора в цикле. В таком случае необходимо использовать неконстантную ссылку:

```cpp
for (string& s : vec) {
    s.push_back('!');
}
```

Передача константной ссылки на объект в функцию, которая не имеет право изменять объект, имеет смысл только в том случае, если копирование объекта является дорогой операцией. В частности, нет никакого смысла в передаче по ссылке объектов `int` или `double`. Это наоборот может привести к потере производительности. Если же мы имеем дело со сложным объектом, таким как `string` или любым контейнером, то передача по константой ссылке является единственным верным решением.

Использование ссылок в C++ не ограничивается передачей параметров в функции, но с этого примера проще всего начать знакомство со ссылками. Ключевое слово `const` также имеет разнообразные применения в C++. О некоторых из них мы поговорим в дальнейшем.

## Резюме

Мы обсудили три способа передачи параметров в функцию:

* передача копии
* передача по ссылке
* передача по константной ссылке

Передавать копию объекта имеет смысл, если копирование стоит дешево, либо когда того требует логика программы. Передача по ссылке используется, если необходимо модифицировать передаваемый объект. Передача по константной ссылке позволяет избежать копирования больших объектов.

## Документация

* [https://isocpp.org/wiki/faq/references](https://isocpp.org/wiki/faq/references)
